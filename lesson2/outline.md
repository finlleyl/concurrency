# Каналы

Каналы позволяют отправлять значения определённого типа между горутинами
и могут синхронизировать их работу

## Создание канала

Каналы создаются функциями ```make(chan тип_элемента)``` или
```make(chan тип_элемента, емкость_канала)```. В первом случае
создастся небуфированный канал, во втором - буферизированный

Буферизированный канал накапливает данные. Когда канал пуст, горутина встаёт
в режим ожидания при чтении. Когда канал полон, горутина встает
в режим ожидания при записи

```go
// создать канал для значений типа int
ch1 := make(chan int)

// создать буферизированный канал для 5 элементов для значений типа string
ch2 := make(chan string, 5)

// создать канал для структур типа MyType
ch3 := make(chan MyType) 
```

Для получения текущего количества элементов в канале и его емкости
используются функции ```len(ch)``` и ```cap(ch)```

Оператор ```ch <- v``` используется для записи в канал, а оператор
```<- ch``` используется для чтения из канала. Если нужно сохранить
значение, то вместо ```<- ch``` используется ```v := <- ch```

Если горутина больше не будет отправлять значения в канал и на это нужно
указать принимающим горутинам, то канал следует закрыть. Для этого нужно
использовать оператор ```close(ch)```. Если канал закрыт, то другие
горутины будут получать нулевые значения

Если горутина отправит данные в закрытый канал, это приведет к панике.
Когда канал перестанет использоваться и на него не будет активных ссылок,
то сборщик мусора освободит память, занятую каналом независимо от
горутин, в которых он используется

Проверить, закрыт канал или нет, можно так: ```i, ok := <-ch```.
Если канал закрыт, значение ```ok``` будет равно ```false```.
Получение двух значений используется, когда необходимо отличать 
нулевое значение, отправленное в канал, от нулевого значения,
возвращаемого из закрытого канала.

## Операторы для работы с каналами

Оператор ```range``` позволяет в цикле принимать значения из канала
до тех пор, пока он не будет закрыт. Например, горутина должна
постоянно получать значения из канала и обрабатывать их
определённым образом. ```range``` используется в канале, который
закрывается, иначе он будет эквивалентен бесконечному циклу.

```go
for i := range ch {
    // тело цикла
} 
```

Если надо ждать сразу несколько каналов:
в одном — результата функции, в другом — сигнала,
что нужно завершить программу, можно использовать оператор ```select```

Для этого создадим канал ```done := make(chan struct{})```.
Его будут читать все горутины

```go
var done = make(chan struct{})

func worker(wg *sync.WaitGroup, i int) {
    for {
        select {
        case <-done:
            fmt.Println("Завершаем", i)
            wg.Done()
            return
        default:
            fmt.Println(i)
        }
        time.Sleep(50 * time.Millisecond)
    }
}

func main() {
    var wg sync.WaitGroup

    // создаём горутины
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go worker(&wg, i)
    }
    time.Sleep(1 * time.Second)
    // сообщаем горутинам о завершении работы
    close(done)
    // ждём завершения всех горутин
    wg.Wait()
} 
```

## Однонаправленные каналы 

Часто каналы передаются в аргументах функций.
Внутри функций каналы используются только для отправки или получения данных.
Если передаваемый в аргументе канал будет использоваться только для чтения
или записи, то для параметра функции можно указать однонаправленный тип канала:

* ```<-chan``` -- только для получения данных. ```par <- chan int```
* ```chan<-``` -- только для отправки данных. ```par chan <- string```

```go
// Generate отправляет в канал out односимвольные строки.
func Generate(out chan<- string) {
    for ch := 'a'; ch <= 'z'; ch++ {
        out <- string([]rune{ch})
    }
    close(out)
}

// Process читает строки из канала in, переводит их в верхний регистр
// и отправляет в канал out.
func Process(in <-chan string, out chan<- string) {
    for v := range in {
        out <- strings.ToUpper(v)
    }
    close(out)
}

func main() {
    lower := make(chan string)
    upper := make(chan string)
    go Generate(lower)
    go Process(lower, upper)

    // выводим строки из канала upper по мере получения
    for s := range upper {
        fmt.Print(s)
    }
} 
```