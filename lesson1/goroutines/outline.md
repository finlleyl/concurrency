# Горутины

Горутина - это функция, которая выполняется с другими функциями
```go
go myFunc()
```

По умолчанию программа завершает работу, не дожидаясь окончательного выполнения
горутин

>При создании горутины в цикле с помощью анонимной функции необходимо
>передавать переменную цикла в горутину
>в виде параметра или определять дополнительную переменную

```go
for i := 0; i < 5; i++ {
    go func(n int) {
        fmt.Println(n)
    }(i)
}
```

# Планировщик горутин

Планировщик горутин - один из элементов рантайма языка. Он отвечает за
выполнение горутин в потоках операционной системы. Планировщик равномерно распределяет
процессорное время между горутинами, учитывая их синхронизацию и системные вызовы

Планировщик горутин работает с тремя типами объектов:
* **Логический процессор.** Ресурс, который объединяет поток операционной системы
  и очередь горутин. Для каждого логического процессора планировщик достаёт одну горутину
  из очереди и запускает её в потоке, используя контекст логического процессора.
* **Поток операционной системы.** Это сущность операционной системы, в которой
  происходит процесс выполнения программного кода. Логический процессор закреплён за
  определённым поток. Если горутина сделала системный вызов, который переводит поток в режим
  ожидания результата, например, чтение из файла, то планировщик создаёт дополнительный
  поток операционной системы. На нём будут запускаться следующие горутины из очереди
  до разблокировки основного потока
* **Горутина.**

# Типы sync.WaitGroup и sync.Once

Переменная типа sync.WaitGroup содержит счётчик горутин, завершения которых
нужно ждать. Функциональность WaitGroup очень проста, состоит всего из трёх методов:
* ```(*WaitGroup) Add(delta int)``` - изменить значение счётчика на указанную величину;
* ```(*WaitGroup) Done()``` - уменьшить значение счётчика на единицу;
* ```(*WaitGroup) Wait()``` - ожидать, когда значение счётчика будет равно нулю.
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    const n = 5

    for i := 0; i < n; i++ {
        wg.Add(1) // инкрементируем счётчик, сколько горутин нужно подождать

        go func(i int) {
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("hi %d\n", i)
            // уменьшаем счётчик, когда горутина завершает работу
            wg.Done()
        }(i)
    }

    wg.Wait() // ждём все горутины
    fmt.Println("Всё готово")
} 
```

Если нужно выполнить действия только один раз, например,
вызвать функцию инициализации при первом обращении к структуре, то
достаточно определить переменную ```sync.Once``` и вызвать для неё
метод ```Do()```, который в параметре принимает функцию инициализации

```go
type Config struct {
    once sync.Once
    vals map[string]string
}

func (c *Config) Get(k string) (string, bool) {
    c.once.Do(func() {
    // эта инициализация выполнится только один раз
        c.vals = map[string]string{
            "host": "127.0.0.1",
            "port": fmt.Sprintf("%d", rand.Intn(65535)),
		}
    })
    
    v, ok := c.vals[k]
    return v, ok
}
```